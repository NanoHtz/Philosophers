Flujo de trabajo de tu Philosophers (paso a paso y al detalle)

A continuación te explico qué hace cada pieza y cómo se coordinan a nivel de hilos, mutexes, tiempos y condiciones de parada. 
Lo estructuro en una línea temporal con invariantes y casos especiales. (Todos los nombres y decisiones están alineados con tu código.)

1 ---- Arranque y configuración

main

Valida argumentos con check_args (números > 0 y dentro de rango).

Reserva e inicializa la mesa con init_table:
	Campos: num_philosophers, time_to_die, time_to_eat, time_to_sleep, must_eat (o -1 si no viene).

Mutexes compartidos:
	forks[i] (uno por tenedor).
	print_mutex (serializa la salida).
	died_mutex (protege la bandera global died).
	died = 0 y start_time = 0 por defecto.

Sincroniza el inicio: fija table->start_time = get_time() + 100 ms (barrera de arranque).

Crea filósofos con init_philosophers:
	Array philos[i] con: id, left_fork = i, right_fork = (i+1)%N, meals_eaten = 0, table, last_meal = start_time, meal_mutex por filósofo.

Ejecuta hilos con create_and_join.

2--- Creación de hilos y monitor

create_and_join

Lanza N hilos de filósofo con pthread_create(..., routine, &philos[i]).

Inserta un pequeño escalonado (usleep(200)) entre creaciones para reducir contención inicial.

Lanza el monitor con start_control:

Crea control_thread que corre control_routine(philos).

Se hace detach (no se joinea: libera recursos al terminar).

Join a todos los hilos de filósofo al acabar la simulación.

Barrera temporal de arranque:
En cada hilo de filósofo, routine espera a que get_time() >= start_time y a que la simulación siga viva (get_died(table)), con bucle de usleep(100).

3--- Monitor de la simulación

control_routine (hilo monitor, desacoplado con detach)

Bucle while (get_died(table)) (importante: get_died devuelve “sigue viva”, es decir table->died == 0).

Condición de éxito (si existe meta de comidas):
Si must_eat > 0 y loop(philos, table) devuelve que todos alcanzaron must_eat, entonces:

set_died(table) → marca final global.

Termina el monitor (return).

Condición de muerte:
loop_2(philos, table) recorre a todos y comprueba si now - last_meal >= time_to_die. Si sí:

Marca died, imprime “died” del filósofo detectado y termina.

Pequeño sleep (usleep(1000)) para evitar busy wait.

Notas clave

El monitor es el árbitro de fin, ya sea por objetivo cumplido o por muerte.

last_meal y meals_eaten se leen bajo meal_mutex para consistencia.

4) Ciclo de un filósofo

routine (por filósofo)

Espera barrera: while (now < start_time && get_died(t)) usleep(100).

Bucle principal while (get_died(t)):

Objetivo de comidas (si must_eat >= 0): bajo meal_mutex, si meals_eaten >= must_eat, sale del bucle (ese filósofo ha terminado).

Caso N == 1: llama a one_philo (ver §7).

Ciclo normal con routine_loop:

Desfase anti-colisión:

stagger_even_first_turn: si N par y id impar y primera comida, espera ~t_eat/2.

stagger_if_odd: si N impar y id par, espera ~t_eat/2.

Objetivo: desincronizar y repartir presión sobre los forks.

Adquisición de forks: take_forks.

Comer: eat.

Soltar forks: unlock_forks.

Dormir y pensar: sleep_and_think.

5) Política de tenedores (evitar deadlock)

take_forks → set_fork_order → acquire_both_forks

Caso N == 1: toma el izquierdo y vuelve (no podrá comer nunca, ver §7).

Orden de toma (f1 y f2):

N par (set_even_order):

Id par: left → right.

Id impar: right → left.

Rompe simetrías.

N impar (set_odd_order):

Primero el tenedor de menor índice.

Impone orden total (jerarquía de recursos).

Tomar ambos (acquire_both_forks):

Primero f1 con lock_fork:

Verifica vida antes y después del lock.

Log “has taken a fork” al éxito.

Segundo f2 con pthread_mutex_trylock:

Si falla, suelta f1 y reintenta tras usleep(800) (backoff).

Si entra, revalida vida; si ya no vive, suelta ambos y sale.

Si sigue viva, log de segundo “has taken a fork” y listo.

Por qué evita deadlock

En N impar: el orden total por índice elimina la espera circular.

En N par: la alternancia por id rompe simetrías.

Además, trylock + backoff evita “acaparar uno y esperar al otro” indefinidamente.

6) Comer, dormir, pensar y logs

eat

start = get_time().

Bajo meal_mutex:

last_meal = start.

Si get_died(t) sigue viva → meals_eaten++ y marca do_print = 1.

Fuera del mutex (para reducir contención):

Si do_print → print_action("is eating").

Espera time_to_eat con micro-sleeps (usleep(100)), verificando vida.

sleep_and_think

Si viva → log “is sleeping”.

Espera time_to_sleep con micro-sleeps (verificando vida).

Si viva → log “is thinking”.

print_action

Serializa con print_mutex.

Imprime: <ms_relativo> <id_base_1> <mensaje> usando ft_time (tiempo relativo a start_time).

Consecuencia: cada comida imprime 3–4 líneas típicas en este orden:

“has taken a fork” (f1)

“has taken a fork” (f2)

“is eating”
(Luego “is sleeping”, “is thinking” en su ciclo.)

7) Caso especial: un único filósofo (N == 1)

one_philo

Toma su tenedor izquierdo (lock_fork).

Espera hasta que pase time_to_die (no puede conseguir el segundo).

Imprime “died” y set_died (para parar globalmente).

Termina el hilo.

8) Señal de fin y shutdown

Detección de fin

Por meta de comidas (must_eat > 0):
El monitor lo comprueba con loop (todos meals_eaten >= must_eat).
Si se cumple → set_died y termina el monitor.

Por muerte (loop_2):
Si alguno supera time_to_die sin comer →
set_died y log “died”.

Propagación del fin

Tras set_died, get_died(table) empieza a devolver 0, con lo que:

Los bucles de filósofos salen.

La adquisición de forks deja de intentarlo y suelta lo tomado.

El monitor sale de su bucle y termina (aunque está detached).

Join y limpieza

create_and_join joinea todos los hilos de filósofo.

En main, se liberan recursos:

free_philo: destruye meal_mutex[i] y libera el array.

free_table: destruye forks[i] y print_mutex, libera forks y table.
(Sugerencia: destruir también died_mutex aquí para simetría.)

Propiedad (ownership) y orden seguro:

Primero destruye mutexes, luego libera memoria.

El monitor ya habrá salido porque died está a 1 (o nunca se libera la mesa antes de que terminen todos los filósofos).

9) Invariantes y garantías de concurrencia

Exclusión en forks: forks[i] (mutex por tenedor).

Logs atómicos: print_mutex asegura líneas no entrelazadas.

Estado global de vida: died bajo died_mutex.

Estadísticas por filósofo: last_meal y meals_eaten bajo meal_mutex.

Sincronía de arranque: start_time + espera activa corta; last_meal = start_time al crear filósofos (los timers empiezan “alineados”).

Evitar deadlock: orden de forks + trylock + backoff + staggering.

10) Camino típico (“ruta feliz”) con N=5

main fija start_time = now + 100ms, crea philos[], lanza hilos y monitor.

Cada routine espera a start_time (barrera), luego entra al bucle.

stagger_if_odd retrasa a ids pares ~t_eat/2; los impares salen antes a por forks.

Cada filósofo toma f1 y luego f2 (con trylock y reintentos).

Comen (is eating), luego duermen y piensan en ciclo.

El monitor vigila muertes y si todos llegaron a must_eat.

Si uno muere → imprime “died” y set_died.

Si todos cumplen → set_died.

Al ponerse died=1, todos salen de sus bucles, se hace join, se libera todo y termina.

11) Cosas finas a tener en mente (ya contempladas)

Nombre get_died: devuelve “sigue viva” (1 si died==0). Funciona perfecto, pero semánticamente puede confundir en lecturas rápidas (si quisieras, podrías renombrarlo a is_alive).

Logs de forks: verás dos “has taken a fork” por cada comida (uno por cada tenedor), por diseño.

Esperas activas: usas micro-sleeps (usleep(100)) para evitar busy-wait puro. Para máxima eficiencia, podrías migrar a cond vars (no es necesario para 42).

12) Checklist mental cuando lees un trace

¿Empiezan todos los logs alrededor del mismo ms? → barrera OK.

¿Cada filósofo imprime 2× “has taken a fork” → “is eating”? → adquisición OK.

¿Ves “is sleeping” → “is thinking” antes del siguiente ciclo? → secuencia OK.

¿Solo un “died” total? → monitor OK.

¿Tras “died”, paran rápido los logs? → propagación OK
