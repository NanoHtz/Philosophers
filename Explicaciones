El objetivo es manejarse con los hilos, los hilos, son una parte de un proceso, un proceso puede estar formado por diferentes hilos, que poseen diferentes datos, pero comparten herramientas comunes (como la memoria.)
Como en una cocina, (el proceso),donde se realizan muchisimas cosas pero donde comparten tenedores, cuchillos(la memoria).

La biblioteca fundamental es: # include <pthread.h>
Es la biblioteca que incluye las fucniones necesarias para los hilos.
Tus estructuras, contaran mínimo con dos elementos:
Una que represente el proceso. La mesa o la cocina.
Otra que represente cada hilo. Los filósofos.

La tabla es donde estaran los mutex (mutual exclusion)
Es un proceso de sincronización, que bloquea datos o acceso a otros hilos
Si otro hilo intenta acceder, se queda esperando hasta que el mutex termine
Es una medida de proteccion de datos.

Un ejemplo: void	*routine(void *arg)
{
	t_philosopher	*philo;

	philo = (t_philosopher *)arg;
	pthread_mutex_lock(&philo->table->print_mutex);
	printf("Filósofo %d ha comenzado.\n", philo->id);
	pthread_mutex_unlock(&philo->table->print_mutex);
	return (NULL);
}

Esta funcion se ejecuta en todos los hilos, sin embargo, cuando se llega a lock
solo uno a uno podran usar printf, hasta que uno no lo desbloquee no avanza.

Es importante destacar, que los hilos son simultaneos, podria ocurrir y de hecho es la naturaleza del
proyecto que tras usar esa funcion, se imprima Filósofo 2 ha comenzado. Filósofo 1 ha comenzado.
estando en ordenes cambiados, es decir de manera desordenada, el ordenador asigna recurso segun los tenga libres, pero los hilos
en estos casos son simultaneos.

create and join -> Al crear un hilo, el sistema reserva recursoso para el hasta que alguien haga join.
Si nunca se hace join, y el hilo termina el sistema se queda colgado y el hilo se queda "zombie"




Debes implementar una simulación donde varios filósofos se sientan alrededor de una mesa y alternan entre tres acciones:
pensar, comer y dormir, utilizando recursos compartidos (tenedores)

Aprendes a usar la biblioteca de pthreads (pthread_create, pthread_join, pthread_mutex_*).

Comprendes qué son data races, condiciones de carrera que pueden provocar errores difíciles de reproducir.

Te enfrentas a la necesidad de sincronizar recursos compartidos entre hilos (tenedores).

Debes cronometrar con precisión cuándo un filósofo come, duerme o muere (gettimeofday, usleep).

Aprendes a controlar el orden y la simultaneidad de las acciones, evitando que los mensajes del log se entremezclen incorrectamente.

Organizar múltiples hilos que comparten recursos te obliga a pensar en arquitectura de software más avanzada.

Manejas estructuras de datos para representar a los filósofos, sus estados y el entorno.

Cada filósofo es un hilo (thread).

Cada tenedor es un mutex compartido entre los filósofos adyacentes.

Los filósofos solo pueden comer si han adquirido los dos mutex (tenedores) que tienen a su izquierda y derecha.

Debes manejar el ciclo de vida de cada filósofo:

Piensa

Coge los tenedores (mutex lock)

Come (temporizador y logs)

Deja los tenedores (mutex unlock)

Duerme

Si un filósofo no ha comido en un tiempo time_to_die, muere y la simulación se detiene.

También puedes implementar un argumento opcional: número de veces que cada filósofo debe comer. Si todos lo logran, la simulación termina sin muertes.

No puedes usar variables globales.

No puede haber data races ni fugas de memoria.

Tienes que registrar con precisión las acciones de cada filósofo con marcas de tiempo.

No puede haber más de 10ms entre que un filósofo muere y se imprime su mensaje de muerte.

 1. Análisis del enunciado y diseño inicial
Leer y entender el problema: reglas, condiciones de parada, formato de logs, uso de mutex.

Planificar las estructuras de datos necesarias (t_philosopher, t_table, t_fork, etc.).

Plan de sincronización para evitar condiciones de carrera y deadlocks.

📍Tiempo estimado: 3-4 horas

🧠 2. Definición de estructuras y parsing de argumentos
Crear structs: filósofo, entorno/mesa, forks, mutex globales.

Parsear y validar argumentos de entrada, incluyendo el argumento opcional.

Crear función init_table para inicializar toda la estructura.

📍Tiempo estimado: 3 horas

🔧 3. Inicialización de mutex y recursos compartidos
Crear mutex por cada tenedor.

Crear mutex para la impresión sincronizada.

Crear mutex para proteger acceso al tiempo de última comida o al contador de comidas.

📍Tiempo estimado: 2-3 horas

🧵 4. Creación de los hilos de filósofos
Crear función philosopher_routine que ejecuta el ciclo vida: pensar → coger tenedores → comer → soltar tenedores → dormir.

Crear los hilos con pthread_create y unirlos con pthread_join.

Asegurarse de que los filósofos estén sentados correctamente respecto a sus tenedores.

📍Tiempo estimado: 4-5 horas

🍴 5. Implementación de la lógica de comida con mutex
Función para coger los tenedores con pthread_mutex_lock.

Registrar logs: has taken a fork, is eating.

Actualizar tiempo de última comida con protección por mutex.

Dormir durante time_to_eat y soltar tenedores (pthread_mutex_unlock).

📍Tiempo estimado: 4 horas

😴 6. Lógica de dormir y pensar
Implementar usleep para time_to_sleep.

Registrar log de sueño y pensamiento.

Añadir thinking al final para evitar bloqueos continuos de forks.

📍Tiempo estimado: 1-2 horas

💀 7. Implementar el monitor de muerte
Hilo separado que revisa constantemente si un filósofo ha pasado más de time_to_die sin comer.

Protección con mutex al leer last_meal.

Finalizar la simulación e imprimir X died en cuanto ocurra.

Evitar imprimir estados después de la muerte.

📍Tiempo estimado: 3-4 horas

🧮 8. Gestión del argumento opcional number_of_times_each_philosopher_must_eat
Añadir un contador en cada filósofo.

Hilo que verifica si todos los filósofos han comido al menos las veces necesarias.

Parar la simulación si se cumple esta condición antes de que alguien muera.

📍Tiempo estimado: 2 horas

🧼 9. Limpieza de memoria y destrucción de mutex
Destruir todos los mutex (pthread_mutex_destroy).

Liberar memoria de structs dinámicos (filósofos, forks, etc.).

Verificar con Valgrind que no haya fugas de memoria.

📍Tiempo estimado: 1.5 horas

📋 10. Gestión de errores, Makefile y pruebas finales
Crear un Makefile limpio con las normas: all, clean, fclean, re.

Manejar errores de argumentos y fallos en malloc, pthread_*, etc.

Crear un pequeño tester o script de pruebas.

Usar gettimeofday correctamente para calcular los logs en milisegundos.

📍Tiempo estimado: 3 horas
